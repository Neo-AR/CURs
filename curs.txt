#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <windows.h>

#define MAX_VERTICES 100
#define MAX_HISTORY 100
#define FILENAME "search_history.txt"

// Структуры данных
typedef struct {
    int size;
    int matrix[MAX_VERTICES][MAX_VERTICES];
    int transposed[MAX_VERTICES][MAX_VERTICES];
} Graph;

typedef struct {
    int vertices[MAX_VERTICES];
    int count;
} Component;

typedef struct {
    char timestamp[50];
    int vertex_count;
    int component_count;
    Component components[MAX_VERTICES];
} SearchResult;

// Глобальные переменные
SearchResult history[MAX_HISTORY];
int history_count = 0;
int N = 7;

// Функции для работы с файлами
void save_to_file(SearchResult result) {
    FILE* file = fopen(FILENAME, "a");
    if (file == NULL) {
        printf("Ошибка открытия файла!\n");
        return;
    }

    fprintf(file, "Дата и время: %s\n", result.timestamp);
    fprintf(file, "Количество вершин: %d\n", result.vertex_count);
    fprintf(file, "Тип связности: ");

    // Определяем тип связности из названий функций
    if (strstr(result.timestamp, "СИЛЬНАЯ")) {
        fprintf(file, "Сильная связность (алгоритм Косарайю)\n");
    }
    else if (strstr(result.timestamp, "СЛАБАЯ")) {
        fprintf(file, "Слабая связность\n");
    }
    else if (strstr(result.timestamp, "НЕОРИЕНТИРОВАННЫЙ")) {
        fprintf(file, "Обычная связность (неориентированный граф)\n");
    }
    else {
        fprintf(file, "Не определен\n");
    }

    fprintf(file, "Количество компонент связности: %d\n", result.component_count);

    for (int i = 0; i < result.component_count; i++) {
        fprintf(file, "Компонента %d: ", i + 1);
        for (int j = 0; j < result.components[i].count; j++) {
            fprintf(file, "%d ", result.components[i].vertices[j] + 1);
        }
        fprintf(file, "\n");
    }
    fprintf(file, "----------------------------------------\n");
    fclose(file);

    printf("Результаты сохранены в файл %s\n", FILENAME);
}

void load_history() {
    FILE* file = fopen(FILENAME, "r");
    if (file == NULL) {
        history_count = 0;
        return;
    }

    char line[256];
    history_count = 0;

    while (fgets(line, sizeof(line), file) && history_count < MAX_HISTORY) {
        if (strstr(line, "Дата и время:")) {
            sscanf(line, "Дата и время: %49[^\n]", history[history_count].timestamp);
        }
        else if (strstr(line, "Количество вершин:")) {
            sscanf(line, "Количество вершин: %d", &history[history_count].vertex_count);
        }
        else if (strstr(line, "Количество компонент связности:")) {
            sscanf(line, "Количество компонент связности: %d",
                &history[history_count].component_count);
        }
        else if (strstr(line, "Компонента")) {
            int comp_index;
            char comp_data[256];
            sscanf(line, "Компонента %d: %[^\n]", &comp_index, comp_data);

            // Парсинг вершин компоненты
            char* token = strtok(comp_data, " ");
            int vertex_count = 0;
            while (token != NULL && vertex_count < MAX_VERTICES) {
                history[history_count].components[comp_index - 1].vertices[vertex_count] =
                    atoi(token) - 1;
                vertex_count++;
                token = strtok(NULL, " ");
            }
            history[history_count].components[comp_index - 1].count = vertex_count;

            // Если это последняя компонента, увеличиваем счетчик
            if (comp_index == history[history_count].component_count) {
                history_count++;
            }
        }
    }

    fclose(file);
}

void view_history() {
    system("cls");
    printf("=== ИСТОРИЯ ПОИСКА ===\n\n");

    if (history_count == 0) {
        printf("История поиска пуста.\n");
        return;
    }

    for (int i = 0; i < history_count; i++) {
        printf("Запись %d:\n", i + 1);
        printf("  Дата и время: %s\n", history[i].timestamp);
        printf("  Количество вершин: %d\n", history[i].vertex_count);
        printf("  Количество компонент: %d\n", history[i].component_count);

        for (int j = 0; j < history[i].component_count; j++) {
            printf("  Компонента %d: ", j + 1);
            for (int k = 0; k < history[i].components[j].count; k++) {
                printf("%d ", history[i].components[j].vertices[k] + 1);
            }
            printf("\n");
        }
        printf("----------------------------------------\n");
    }

    printf("\nНажмите любую клавишу для продолжения...");
    getchar();
    getchar();
}

// Функции алгоритма Косарайю
void transpose_graph(Graph* g) {
    if (g->size <= 10) {
        printf("\n=== ПРОЦЕСС ТРАНСПОНИРОВАНИЯ ГРАФА ===\n");
        printf("Исходная матрица смежности:\n");
        printf("   ");
        for (int j = 0; j < g->size; j++) printf("%3d", j + 1);
        printf("\n");
        for (int i = 0; i < g->size; i++) {
            printf("%3d", i + 1);
            for (int j = 0; j < g->size; j++) {
                printf("%3d", g->matrix[i][j]);
            }
            printf("\n");
        }
    }

    // Транспонирование: меняем строки и столбцы местами
    for (int i = 0; i < g->size; i++) {
        for (int j = 0; j < g->size; j++) {
            g->transposed[j][i] = g->matrix[i][j];
        }
    }

    if (g->size <= 10) {
        printf("\nТранспонированная матрица смежности:\n");
        printf("   ");
        for (int j = 0; j < g->size; j++) printf("%3d", j + 1);
        printf("\n");
        for (int i = 0; i < g->size; i++) {
            printf("%3d", i + 1);
            for (int j = 0; j < g->size; j++) {
                printf("%3d", g->transposed[i][j]);
            }
            printf("\n");
        }

        // Наглядное объяснение
        printf("\nНаглядное представление транспонирования:\n");
        printf("Каждое ребро меняет направление на противоположное:\n");
        for (int i = 0; i < g->size; i++) {
            for (int j = 0; j < g->size; j++) {
                if (g->matrix[i][j] == 1) {
                    printf("  Ребро %d --> %d становится %d --> %d\n",
                        i + 1, j + 1, j + 1, i + 1);
                }
            }
        }
        printf("Нажмите любую клавишу для продолжения...\n");
        getchar();
    }
}

/*
 * Первый обход в глубину для заполнения стека завершения вершин
 * Стек заполняется в порядке завершения обработки вершин
 */
void fill_order(int v, int visited[], int stack[], int* index, Graph* g) {
    visited[v] = 1;

    for (int i = 0; i < g->size; i++) {
        if (g->matrix[v][i] && !visited[i]) {
            printf("  Переход из вершины %d в вершину %d\n", v + 1, i + 1);
            fill_order(i, visited, stack, index, g);
        }
    }

    // Добавляем вершину в стек после обработки всех её соседей
    stack[++(*index)] = v;
    printf("  Вершина %d полностью обработана и добавлена в стек\n", v + 1);
}

/*
 * Обход в глубину на транспонированном графе для поиска компонент сильной связности
 * Все вершины, достижимые из данной на транспонированном графе, образуют одну компоненту
 */
void DFSUtil(int v, int visited[], Component* comp, Graph* g, int use_transposed) {
    visited[v] = 1;
    comp->vertices[comp->count++] = v;

    for (int i = 0; i < g->size; i++) {
        int edge_exists = use_transposed ? g->transposed[v][i] : g->matrix[v][i];
        if (edge_exists && !visited[i]) {
            printf("  Переход из вершины %d в вершину %d\n", v + 1, i + 1);
            DFSUtil(i, visited, comp, g, use_transposed);
        }
    }
}

void kosaraju(Graph* g, SearchResult* result, int show_steps) {
    int stack[MAX_VERTICES];
    int stack_index = -1;
    int visited[MAX_VERTICES];

    // Инициализация массива посещенных вершин
    for (int i = 0; i < g->size; i++) {
        visited[i] = 0;
    }

    if (show_steps) {
        printf("\n========================================\n");
        printf("ШАГ 1: ПЕРВЫЙ ОБХОД В ГЛУБИНУ (DFS)\n");
        printf("Цель: Определить порядок завершения обработки вершин\n");
        printf("Стек заполняется в порядке убывания времени завершения\n");
        printf("========================================\n");
    }

    // ШАГ 1: Первый обход в глубину для заполнения стека
    for (int i = 0; i < g->size; i++) {
        if (!visited[i]) {
            if (show_steps) {
                printf("\nНачинаем обход из вершины %d:\n", i + 1);
            }
            fill_order(i, visited, stack, &stack_index, g);
        }
    }

    if (show_steps) {
        printf("\nСодержимое стека (вершины в порядке завершения обработки):\n");
        printf("Вершины: ");
        for (int i = 0; i <= stack_index; i++) {
            printf("%d ", stack[i] + 1);
        }
        printf("\n");
        printf("(Вершина вверху стека: %d, внизу: %d)\n",
            stack[stack_index] + 1, stack[0] + 1);
        printf("\nНажмите любую клавишу для продолжения...\n");
        getchar();
    }

    // ШАГ 2: Транспонирование графа
    transpose_graph(g);

    // Сброс массива посещенных вершин для второго обхода
    for (int i = 0; i < g->size; i++) {
        visited[i] = 0;
    }

    if (show_steps) {
        printf("\n========================================\n");
        printf("ШАГ 3: ВТОРОЙ ОБХОД В ГЛУБИНУ\n");
        printf("Цель: Найти компоненты сильной связности\n");
        printf("Обход идет по транспонированному графу в порядке из стека\n");
        printf("Каждое дерево поиска - одна компонента сильной связности\n");
        printf("========================================\n");
    }

    // ШАГ 3: Второй обход в глубину по порядку из стека
    result->component_count = 0;
    while (stack_index >= 0) {
        int v = stack[stack_index--];

        if (!visited[v]) {
            if (show_steps) {
                printf("\n--- Начинаем обход из вершины %d (корень компоненты) ---\n", v + 1);
            }

            Component new_comp;
            new_comp.count = 0;
            DFSUtil(v, visited, &new_comp, g, 1);

            // Сохраняем найденную компоненту
            result->components[result->component_count] = new_comp;

            if (show_steps) {
                printf("Найдена компонента сильной связности %d: ", result->component_count + 1);
                for (int j = 0; j < new_comp.count; j++) {
                    printf("%d ", new_comp.vertices[j] + 1);
                }
                printf("\n");
            }

            result->component_count++;
        }
    }

    // Заполняем информацию о результате поиска
    result->vertex_count = g->size;
    time_t now = time(NULL);
    struct tm* t = localtime(&now);
    strftime(result->timestamp, sizeof(result->timestamp),
        "%d.%m.%Y %H:%M:%S [СИЛЬНАЯ СВЯЗНОСТЬ]", t);
}

// Функция для поиска слабой связности в орграфе
void find_weak_connectivity(Graph* g, SearchResult* result, int show_steps) {
    int visited[MAX_VERTICES] = { 0 };
    result->component_count = 0;
    result->vertex_count = g->size;

    time_t now = time(NULL);
    struct tm* t = localtime(&now);
    strftime(result->timestamp, sizeof(result->timestamp),
        "%d.%m.%Y %H:%M:%S [СЛАБАЯ СВЯЗНОСТЬ]", t);

    if (show_steps) {
        printf("\n========================================\n");
        printf("АЛГОРИТМ ПОИСКА СЛАБОЙ СВЯЗНОСТИ\n");
        printf("========================================\n");
        printf("Принцип: игнорируем направление рёбер\n");
        printf("Считаем граф неориентированным:\n");
        printf("- Если есть ребро i->j, считаем связь i<->j\n");
        printf("- Если есть ребро j->i, считаем связь i<->j\n");
        printf("========================================\n");
    }

    for (int i = 0; i < g->size; i++) {
        if (!visited[i]) {
            Component comp;
            comp.count = 0;

            // Используем стек для DFS
            int stack[MAX_VERTICES];
            int top = -1;

            stack[++top] = i;
            visited[i] = 1;

            if (show_steps) {
                printf("\nНачинаем обход из вершины %d (корень компоненты %d):\n",
                    i + 1, result->component_count + 1);
            }

            while (top >= 0) {
                int v = stack[top--];
                comp.vertices[comp.count++] = v;

                if (show_steps) {
                    printf("  Обрабатываем вершину %d\n", v + 1);
                }

                // Проверяем все вершины, связанные в ЛЮБОМ направлении
                for (int j = 0; j < g->size; j++) {
                    // Если есть ребро в ЛЮБОМ направлении
                    if ((g->matrix[v][j] == 1 || g->matrix[j][v] == 1) && !visited[j]) {
                        visited[j] = 1;
                        stack[++top] = j;

                        if (show_steps) {
                            if (g->matrix[v][j] == 1 && g->matrix[j][v] == 1) {
                                printf("    Переход к вершине %d (двунаправленная связь)\n", j + 1);
                            }
                            else if (g->matrix[v][j] == 1) {
                                printf("    Переход к вершине %d (ребро %d->%d)\n", j + 1, v + 1, j + 1);
                            }
                            else {
                                printf("    Переход к вершине %d (обратное ребро %d->%d)\n",
                                    j + 1, j + 1, v + 1);
                            }
                        }
                    }
                }
            }

            // Сохраняем найденную компоненту
            result->components[result->component_count] = comp;

            if (show_steps) {
                printf("  Найдена компонента слабой связности %d: { ",
                    result->component_count + 1);
                for (int j = 0; j < comp.count; j++) {
                    printf("%d ", comp.vertices[j] + 1);
                }
                printf("} (размер: %d)\n", comp.count);
            }

            result->component_count++;
        }
    }
}

// Функции для работы с графами 
void generate_directed_graph(Graph* g) {
    srand(time(NULL));

    // ШАГ 1: Инициализация всей матрицы нулями
    for (int i = 0; i < g->size; i++) {
        for (int j = 0; j < g->size; j++) {
            g->matrix[i][j] = 0;
        }
    }

    // ШАГ 2: Генерация рёбер 
    printf("\nГенерация ориентированного графа...\n");
    printf("Правила генерации:\n");
    printf("1. Петли (ребра из вершины в себя) не генерируются\n");
    printf("2. Вероятность создания ребра между двумя разными вершинами: 40%%\n");
    printf("3. Ребра могут быть однонаправленными или двунаправленными\n");

    int edge_count = 0;
    for (int i = 0; i < g->size; i++) {
        for (int j = 0; j < g->size; j++) {
            if (i != j) { // Исключаем петли
                if (i < j) { // Обрабатываем только верхний треугольник для избежания дублирования
                    int probability = rand() % 100;

                    if (probability < 40) { 
                        // Создаем однонаправленное или двунаправленное ребро
                        int direction = rand() % 3;

                        switch (direction) {
                        case 0: // i → j
                            g->matrix[i][j] = 1;
                            printf("  Создано ребро: %d -> %d\n", i + 1, j + 1);
                            edge_count++;
                            break;
                        case 1: // j → i
                            g->matrix[j][i] = 1;
                            printf("  Создано ребро: %d -> %d\n", j + 1, i + 1);
                            edge_count++;
                            break;
                        case 2: // i ↔ j (двунаправленное)
                            g->matrix[i][j] = 1;
                            g->matrix[j][i] = 1;
                            printf("  Создано двунаправленное ребро: %d <-> %d\n", i + 1, j + 1);
                            edge_count += 2;
                            break;
                        }
                    }
                }
            }
        }
    }

    printf("Всего создано ребер: %d\n", edge_count);

    // ШАГ 3: Гарантируем, что у каждой вершины есть хотя бы одно исходящее ребро
    for (int i = 0; i < g->size; i++) {
        int has_outgoing = 0;
        for (int j = 0; j < g->size; j++) {
            if (g->matrix[i][j] == 1) {
                has_outgoing = 1;
                break;
            }
        }

        if (!has_outgoing && g->size > 1) {
            // Добавляем случайное исходящее ребро
            int target;
            do {
                target = rand() % g->size;
            } while (target == i);

            g->matrix[i][target] = 1;
            printf("  Добавлено обязательное ребро: %d → %d\n", i + 1, target + 1);
            edge_count++;
        }
    }
}

void generate_undirected_graph(Graph* g) {
    srand(time(NULL));

    // Инициализация нулями
    for (int i = 0; i < g->size; i++) {
        for (int j = 0; j < g->size; j++) {
            g->matrix[i][j] = 0;
        }
    }

    printf("\nГенерация неориентированного графа...\n");
    printf("Правила генерации:\n");
    printf("1. Петли не генерируются\n");
    printf("2. Вероятность создания ребра: 30%%\n");
    printf("3. Все рёбра двунаправленные\n");

    int edge_count = 0;
    // Генерация неориентированного графа (симметричная матрица)
    for (int i = 0; i < g->size; i++) {
        for (int j = i + 1; j < g->size; j++) {
            if (rand() % 100 < 30) { 
                g->matrix[i][j] = g->matrix[j][i] = 1;
                printf("  Создано ребро: %d — %d\n", i + 1, j + 1);
                edge_count++;
            }
        }
    }

    printf("Всего создано ребер: %d\n", edge_count);
}

void print_matrix(Graph* g) {
    printf("\n=== МАТРИЦА СМЕЖНОСТИ ===\n");
    printf("(1 - есть ребро, 0 - нет ребра)\n\n");

    printf("     ");
    for (int j = 0; j < g->size; j++) {
        printf("%4d  ", j + 1);
    }
    printf("\n");

    printf("     ");
    for (int j = 0; j < g->size; j++) {
        printf("------");
    }
    printf("\n\n");

    // Строки матрицы
    for (int i = 0; i < g->size; i++) {
        printf("%3d |", i + 1);
        for (int j = 0; j < g->size; j++) {
            printf("%4d  ", g->matrix[i][j]);
        }
        printf("\n\n");
    }
}

void print_connections(Graph* g) {
    printf("\n=== СПИСОК ИСХОДЯЩИХ СВЯЗЕЙ ===\n");
    printf("(Для ориентированного графа)\n\n");

    for (int i = 0; i < g->size; i++) {
        printf("Вершина %d --> { ", i + 1);
        int has_connections = 0;

        for (int j = 0; j < g->size; j++) {
            if (g->matrix[i][j]) {
                printf("%d ", j + 1);
                has_connections = 1;
            }
        }

        if (!has_connections) {
            printf("нет исходящих связей");
        }
        printf(" }\n");
    }
}

// функции меню
void print_header() {
    system("cls");
    printf("===================================================\n");
    printf("          КУРСОВАЯ РАБОТА\n");
    printf("          по дисциплине \"Логика и основы алгоритмизации\"\n");
    printf("          Тема: Реализация алгоритма поиска компонент связности\n");
    printf("                в орграфе, используя поиск в глубину\n\n");
    printf("          Студент: Тусков Арсений Андреевич\n");
    printf("          Группа: 24-ВВВ1\n");
    printf("          Преподаватель: Юрова О.В.\n");
    printf("===================================================\n\n");
}

void set_vertex_count() {
    printf("Текущее количество вершин: %d\n", N);
    printf("Введите новое количество вершин (2-%d): ", MAX_VERTICES);

    int new_count;
    scanf("%d", &new_count);

    if (new_count >= 2 && new_count <= MAX_VERTICES) {
        N = new_count;
        printf("Количество вершин изменено на %d\n", N);
    }
    else {
        printf("Некорректное значение!\n");
    }

    printf("Нажмите любую клавишу для продолжения...");
    getchar();
    getchar();
}

void process_strong_connectivity() {
    Graph g;
    g.size = N;

    printf("\n=== СИЛЬНАЯ СВЯЗНОСТЬ ОРИЕНТИРОВАННОГО ГРАФА ===\n");
    printf("(Алгоритм Косарайю)\n");
    generate_directed_graph(&g);
    print_matrix(&g);
    print_connections(&g);

    int show_steps;
    printf("\nПоказывать подробные шаги алгоритма Косарайю? (1 - да, 0 - нет): ");
    scanf("%d", &show_steps);

    SearchResult result;
    kosaraju(&g, &result, show_steps);

    printf("\n========================================\n");
    printf("ФИНАЛЬНЫЕ РЕЗУЛЬТАТЫ (СИЛЬНАЯ СВЯЗНОСТЬ)\n");
    printf("========================================\n");
    printf("Количество компонент сильной связности: %d\n", result.component_count);
    printf("Всего вершин в графе: %d\n", result.vertex_count);

    if (result.component_count == 1) {
        printf("\nГраф является СИЛЬНО СВЯЗНЫМ!\n");
        printf("Любая вершина достижима из любой другой.\n");
    }
    else if (result.component_count == result.vertex_count) {
        printf("\nКаждая вершина образует отдельную компоненту.\n");
        printf("В графе нет сильных связей между вершинами.\n");
    }

    printf("\nКомпоненты сильной связности:\n");
    for (int i = 0; i < result.component_count; i++) {
        printf("Компонента %d (размер: %d): { ", i + 1, result.components[i].count);
        for (int j = 0; j < result.components[i].count; j++) {
            printf("%d ", result.components[i].vertices[j] + 1);
        }
        printf("}\n");
    }

    char save;
    printf("\nСохранить результаты в файл? (y/n): ");
    scanf(" %c", &save);

    if (save == 'y' || save == 'Y') {
        save_to_file(result);
        history[history_count++] = result;
    }

    printf("\nНажмите любую клавишу для продолжения...");
    getchar();
    getchar();
}

void process_weak_connectivity() {
    Graph g;
    g.size = N;

    printf("\n=== СЛАБАЯ СВЯЗНОСТЬ ОРИЕНТИРОВАННОГО ГРАФА ===\n");
    printf("(Игнорируем направление рёбер)\n");
    generate_directed_graph(&g);
    print_matrix(&g);
    print_connections(&g);

    int show_steps;
    printf("\nПоказывать подробные шаги алгоритма? (1 - да, 0 - нет): ");
    scanf("%d", &show_steps);

    SearchResult result;
    find_weak_connectivity(&g, &result, show_steps);

    printf("\n========================================\n");
    printf("ФИНАЛЬНЫЕ РЕЗУЛЬТАТЫ (СЛАБАЯ СВЯЗНОСТЬ)\n");
    printf("========================================\n");
    printf("Количество компонент слабой связности: %d\n", result.component_count);
    printf("Всего вершин в графе: %d\n", result.vertex_count);

    if (result.component_count == 1) {
        printf("\nГраф является СЛАБО СВЯЗНЫМ!\n");
        printf("Если игнорировать направление рёбер, граф связен.\n");
    }
    else if (result.component_count == result.vertex_count) {
        printf("\nКаждая вершина изолирована.\n");
        printf("Даже без учета направления рёбер вершины не связаны.\n");
    }

    printf("\nКомпоненты слабой связности:\n");
    for (int i = 0; i < result.component_count; i++) {
        printf("Компонента %d (размер: %d): { ", i + 1, result.components[i].count);
        for (int j = 0; j < result.components[i].count; j++) {
            printf("%d ", result.components[i].vertices[j] + 1);
        }
        printf("}\n");
    }

    char save;
    printf("\nСохранить результаты в файл? (y/n): ");
    scanf(" %c", &save);

    if (save == 'y' || save == 'Y') {
        save_to_file(result);
        history[history_count++] = result;
    }

    printf("\nНажмите любую клавишу для продолжения...");
    getchar();
    getchar();
}

void process_undirected_graph() {
    Graph g;
    g.size = N;

    printf("\n=== СВЯЗНОСТЬ НЕОРИЕНТИРОВАННОГО ГРАФА ===\n");
    generate_undirected_graph(&g);
    print_matrix(&g);

    // Для неориентированного графа алгоритм
    int visited[MAX_VERTICES] = { 0 };
    SearchResult result;
    result.component_count = 0;
    result.vertex_count = g.size;

    time_t now = time(NULL);
    struct tm* t = localtime(&now);
    strftime(result.timestamp, sizeof(result.timestamp),
        "%d.%m.%Y %H:%M:%S [НЕОРИЕНТИРОВАННЫЙ]", t);

    printf("\n=== ПОИСК КОМПОНЕНТ СВЯЗНОСТИ ===\n");
    printf("(Для неориентированного графа)\n");

    for (int i = 0; i < g.size; i++) {
        if (!visited[i]) {
            Component comp;
            comp.count = 0;

            // DFS для неориентированного графа
            int stack[MAX_VERTICES];
            int top = -1;

            stack[++top] = i;
            visited[i] = 1;

            while (top >= 0) {
                int v = stack[top--];
                comp.vertices[comp.count++] = v;

                for (int j = 0; j < g.size; j++) {
                    if (g.matrix[v][j] && !visited[j]) {
                        visited[j] = 1;
                        stack[++top] = j;
                    }
                }
            }

            result.components[result.component_count++] = comp;
        }
    }

    printf("\n=== РЕЗУЛЬТАТЫ ===\n");
    printf("Количество компонент связности: %d\n", result.component_count);

    if (result.component_count == 1) {
        printf("\nГраф является СВЯЗНЫМ!\n");
    }

    for (int i = 0; i < result.component_count; i++) {
        printf("Компонента %d (размер: %d): { ", i + 1, result.components[i].count);
        for (int j = 0; j < result.components[i].count; j++) {
            printf("%d ", result.components[i].vertices[j] + 1);
        }
        printf("}\n");
    }

    char save;
    printf("\nСохранить результаты в файл? (y/n): ");
    scanf(" %c", &save);

    if (save == 'y' || save == 'Y') {
        save_to_file(result);
        history[history_count++] = result;
    }

    printf("Нажмите любую клавишу для продолжения...");
    getchar();
    getchar();
}

int main() {
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    load_history();

    while (1) {
        print_header();

        printf("МЕНЮ:\n");
        printf("1. Установить количество вершин (текущее: %d)\n", N);
        printf("2. Сильная связность ориентированного графа (алгоритм Косарайю)\n");
        printf("3. Слабая связность ориентированного графа\n");
        printf("4. Неориентированный граф\n");
        printf("5. Просмотреть историю поиска\n");
        printf("6. Выход\n");
        printf("\nВыберите пункт меню: ");

        int choice;
        scanf("%d", &choice);

        switch (choice) {
        case 1:
            set_vertex_count();
            break;
        case 2:
            process_strong_connectivity();
            break;
        case 3:
            process_weak_connectivity();
            break;
        case 4:
            process_undirected_graph();
            break;
        case 5:
            view_history();
            break;
        case 6:
            printf("Выход из программы...\n");
            return 0;
        default:
            printf("Некорректный выбор!\n");
            printf("Нажмите любую клавишу для продолжения...");
            getchar();
            getchar();
            break;
        }
    }

    return 0;
}